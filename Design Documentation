#DESIGN DOCUMENTATION
The B+ tree program is implemented as an on-disk data structure. The data structure takes the form of a data base allowing the user to search, insert, remove, and modify records. The database is held on the disk as a .txt file. Because databases can become quite large, there may come a time when all the database cannot fit in memory at one given time. For this reason, the database was held on the disk as a text file.
To implement the program, the B+ tree uses created features such as blocks, records, fields, relative record pointers, relative block pointers, and the distinction between leaf and non-leaf blocks.
The created program maintains a B+ tree where all keys are stored, with their relative data, in the leaves of the tree. Each leaf of the tree will be stored in a block. Blocks may contain up to four leaves at any given time. Non-leaf blocks also referred to as internal blocks will store keys and contain pointers which lead to the leaves. Meaning, anytime a key is searched, the search will begin at the root, and end at a leaf with the record’s contents.
This program will be developed in chunks of code due to the fact that it will become quite large when completely implemented.
To begin, the structure of fields will first be considered. There will be a total of six fields per record including the primary key. The primary key will be chosen as the zip code of each record because it is distinct from all other records. The fields will be as follows; zip, city, state, county, latitude, and longitude. When a field is brought into memory, it will be read in within a struct. Within the struct, each field will be held as a fixed length char array. This struct will appear in the file containing the leafBlock class which will be discussed in a later section. An example of how the struct may appear is shown in Figure 1.
 
Figure 1. Structure of each record.
As can be seen in Figure 1, each field will be of a fixed size. Zip has a size of six because each zip code can have a maximum of five digits + ‘\0’. The same is true of state since each state is abbreviated. City and county contain the greatest number of characters and as such will be provided the largest of char arrays within each record struct. Each struct will take 104 bytes of space. Char arrays will be chosen because their size can be fixed. This fixed size is helpful when fixing the size of the record overall. 
Along with each record, three pointers will also be used to create a doubly linked list as part of the sequence set and have one pointer pointing to the record’s parent. The pointers will be referred to as left, right, and parent. The left pointer will point to the record preceding and the right pointer will point to the proceeding record. Creating a parent pointer will be useful for splitting, merging, and redistribution. Each pointer will be assigned 8 bytes for a total of 24. This equates to a total of 128 bytes per record being allotted in space. When considering a blocking factor of 4 records per block, that means blocks will be 512 bytes each.
Creating a header record will be the next item to accomplish. The header record is useful in detailing information about the data file. The header record will be the first part of the sequence set and will be brought into memory when any operations on the data are carried out. The header record will contain a number of fields and will be included in the BPlusTree class file to also be later discussed. The header record will be included in the private section of the BPlusTree class to keep information about the database hidden from the user. Figure 2 depicts an example of how the header record will appear within the BPlusTree class.
 
Figure 2. Header record components.
Each piece of information within the header record will be outputted to the sequence set and will be the first items to appear. Outputting this information to the sequence set will free up space within memory so this information will not need to be kept. However, while operations are being performed on the data set, header information will be read in, kept, and updated while operations are being performed. The header record components will be initialized immediately when it is determined by user input that a new B+ Tree is to be created. The list of header record components in Figure 2 is not set and may be added to as new pieces of information are found to be relevant pertaining to the data file. The header record will be assigned 512 bytes in order to keep the numbers relatively similar to the block size of records.
The next aspect of the program that will be researched are the index set blocks (internal blocks) of the program. The internal blocks will be created based on the input of the user. The user will be allowed to select the order of the B+ Tree. The order will only be considered for internal blocks and not leaf blocks. For example, if the user selects an order of 4, at most three keys will be held within each internal block. If three keys are able to be held within an internal block, at most four pointers will also be held. These pointers will point to children blocks.
When searching for a particular zip code, the search will begin at the root, and work down until the record is either found, or determined does not exist within the tree. The pointers of internal blocks will facilitate movement down the database document until the record is found and moved into memory. 
Since the user is able to select the order of the index set blocks, the size will be determined by the input. Each key within the index set block will be allotted 8 bytes. Each child pointer will also be allotted 8 bytes. Because block size has previously been determined to be 512 bytes, the number of keys within an index set block could become quite large. At most the user could select an order of 32. This would give 31 keys * 8 bytes per key = 248 bytes. Up to 32 pointers could be used * 8 bytes per pointer = 256 bytes. 248 bytes + 256 bytes = 504 bytes maximum bytes possible. Within each index set block, the relative block number will also be identified. The root block will have a relative block number (RBN) of 0. The next block will have an RBN of 1 and so on. RBNs will also be allotted 8 bytes. So, referring to the previous example, if the user selected an order of 32, 8 bytes will also be added to the total of 504 blocks to give a new total of 512 blocks equaling the maximum block size. 
When implementing the B+ tree, the fill factor must also be considered. For this project, it was determined that a fill factor of 75% was best suited. This fill factor was chosen because records will have equal opportunity of being added to and removed from the B+ Tree. The fill factor will also be held within the InternalBlock class since it only pertains to non-leaf blocks. When it is determined that a block has reached 75% of total block size, an additional block will be created and half of the current block will be migrated to the new block.
After the initial completion of the previous steps outlined, the sequence set will be constructed from the data file. To implement the sequence set, a new file will need to be created for data migration and proper formatting. Again, the header record will be the first part of the sequence file created. When each record is being read in, the header record components in memory will be updated. The sequence set will be outputted to the file as follows. Following header record components, the first 4 records will create the first leaf block. The fields of each record will be outputted to the sequence set along with the record’s pointers. These pointers will act as byte offsets to the next and previous records. Because each record is 128 bytes in length, the right pointer will be an additional 128 bytes from the current record. The left pointer will be subtracted by 128 bytes to indicate the previous record. Once these four records have been read into a leaf block, the next four records will be brought in.
These four records will also represent the first internal block. The internal block will contain the record’s keys and a pointer to that block. After this is complete, another set of records will be read in with the same steps being taken. Once the whole file has been read in, the data file will be closed. At this point, the header record’s contents within the formatted file will be modified to reflect the entire data file. 
Once the sequence set has been successfully created and ran, then the index set can begin to be constructed. The index set will contain only the non-leaf nodes. Creating an index set will reduce the number of searches need to locate a particular record. The index set will be built from the sequence set. To build the index set, internal blocks will be used with keys and relative block numbers of children blocks. the index set will be built upwards beginning with the first record pointers and keys of the sequence file. Once an index set block has been filled to 75%, that block will be split with half of its contents being shifted to the next block. Also, each right-most key in a block will be promoted to it’s parent unless the block is the index set root.  Initially, the first block will be split twice with one of the three blocks being promoted to the root. To reduce the number of block splits, rotations will be incorporated. A rotation will occur when one block has reach capacity, but one of its siblings is not full. Rather than splitting, the key can be moved to its sibling adjusting the indices as necessary. These operations will continue until all off the sequence file has been read and the index set successfully built.
Once the index set and sequence set have been successfully constructed, operations such as insert, remove, and modify can begin to be implemented. The modify function can be attacked first because that should be the easiest to implement. When modifying a record, the records key (zip code) will be entered by the user in the driver program (main). The zip code will be sent to the index set where the RBN of the record containing the key resides. The sequence set will then be invoked with the relative block number and key. The zip code will be found using these pieces of information and the record will be loaded into memory where the user can make changes. Once the user has completed making changes, those changes will be updated in the sequence set, leaving untouched the RBN.
When a user wishes to add a new record, there are a couple of tests that will need to be ran to determine how it may or may not effect the leaf block and internal blocks associated with the new key. If the leaf block and index block pertaining to the new record are not full, the new record and its key can simply be inserted while updating the pointers to the previous and next record. Each new insertion can be placed at the end of the sequence set as long as the pointers are correct. 
If the leaf block of the new record is full but the internal block is not, the leaf block will need to be split. The new key can be placed into the internal block without change. The new left leaf block will contain records less than the parent internal block pointing to it. The new right key page will contain records greater than or equal to the parent block pointing to it. Left and right pointers will be updated to reflect the insertion. 
If both the leaf block and internal block are full, both blocks will need to be split if keys cannot be shifted to sibling blocks. If the leaf block needs to be split, the same steps can be taken above. If the internal block needs to be split, the same steps can also be taken that were used to split the leaf block. If it is found that the next level of the internal block is full, continued splitting of blocks will occur if no keys can be slid to sibling blocks.
When a user elects to delete a record from the B+ tree, the same set of scenarios regarding leaf and internal blocks will be observed with different action being taken. If the deletion of a record causes leaf block to become empty, split the left or right sibling block and adjust the left and right pointers of the records. If deleting the key of the record makes the internal block fall below 50%, attempt to take a key from the left or right sibling. If this action causes both to fall below 50%, merge the two internal blocks and readjust the key pointers.
 
If the leaf page becomes empty with the removal of the record, but the internal block does not fall below 50%; perform the same steps listed above in regards to the leaf block.
If neither the leaf block becomes empty or the internal block falls below 50% with the removal of the record, simply update the left and right pointers of the records. The record itself does not necessarily need to be removed from the document as long as pointers are updated to point around the now obsolete record. If the deleted record’s key appears on the internal block, delete that key and use the next key to replace it.
To facilitate the operations able to be performed in the B+ Tree program, a number of different classes and files will be used to enhance readability and ease of understanding. These classes and their functions can be seen in Figure 3. Figure 3 serves only as a starting point, and may be modified as the project progresses.
The main.cpp file will act as the driver to the program. This file will take in user input and call functions to carry out operations as specified by the user. Main will run in a while loop and a menu will be displayed for the user to make choices. These choices will include adding, deleting, modifying, and searching the tree for a record. There will also be an option to print the tree or print just the leaves of the tree. More options will include checking whether or not the tree is empty and the height of the tree. There will be a menu choice to display the menu and a choice to quit the program also.
There will also be a file block.cpp which will contain the block class. The block class will contain the header record and operations to assist in the manipulation of the tree as specified by the user. Some of these operations include checking whether or not underflow or overflow will occur with add and remove operations of records. More operations will getting the key specified by the user in order to return or modify a record. The Block class will also have to be able to check the siblings and parents of records.
There will also be another file leafBlock.cpp to hold the leafBlock class to assist in operations that are performed on leaf blocks. Some of these functions include a Boolean function returning true if the record is a leaf. Getting the record for modification is also a function. Insertion and deletion of records will also be included in this class.
 
There will also be an internalBlock.cpp file to hold the InternalBlock class. Within the InternalBlock class, functions such as getting the child block, inserting and deleting a block will be included. A Boolean function will also be input to return true if the block is an internal block. The internal block will also hold a struct of the internal block. A search function will also be inputted to locate the RBN of a key that is being searched. 
 
Figure 3. Figure 3 depicts the classes of the B+ tree program with the proposed files. 
Figure 3 shows some of the functions and classes that will be used to construct the B+ Tree program. These classes are not concrete but should serve as a starting point to assist in the successful completion of the program. The program is ran in main and main communicates with block.cpp. The Block class will hold the header components and serve as the driver for all operations to be carried out on leaf blocks and internal blocks. The leaf block will only be able to access blocks that are leaves. Information within the leaves could contain, the record, the left and right pointers, the parent pointers, and the byte offsets. When information is requested from leaves, it will be passed back to the block class. The same rules apply to the InternalBlock class. The internal blocks will not have access to leaf blocks unless it is through the Block class. 
